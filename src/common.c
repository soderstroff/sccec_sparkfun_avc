/*
 * Sierra College Computer Engineering Club: Sparkfun AVC
 * Common header file for any definitions we might need in each module
 * Includes utility and math functions.
 * Authors: James Smith, Kristoffer Semelka
 *
 * Todo: Implement stubs to finalize port.
 * For each resolved stub, move prototype in common.h from
 * UNIMPLEMENTED PROTOTYPES to PROTOTYPES.
 */
#include "common.h"
#include <math.h>
#include "i2c.h"

/* UNIMPLEMENTED FUNCTION STUBS */
/* Time functions, should be replaced by RTI Module calls */

void delay(uint8_t time)
{
	/* Delays some by some integer amount. */
	;
}

void delayMicroseconds(uint8_t ms)
{
	/* Delays by some integer amount of microseconds. */
	;
}
uint32_t millis()
{
	/* Returns time passed in milliseconds.
	 * We should probably use the RTI module instead. */
	return 0;
}

/* serial port functions; should use calls from spi.h */
void print(char* toPrint)
{
	/* Prints a string to serial. See spi.h */
	;
}
void printChar(char c)
{
	/* Prints a single byte/character to serial. */
	;
}
uint8_t available()
{
	/* Returns how many bytes are available in spi buffer, e.g.
	 * radio communication.
	 */
	return 0.f;
}

void readBytes(char* dest, uint8_t n)
{
	/* Reads n bytes into dest buffer. */
	;
}
void printFormat(uint8_t value, format f)
{
	/* Prints value in format f (valid formats are BIN, DEC, and HEX). */
	switch (f)
	{
		case BIN:
			break;

		case DEC:
			break;

		case HEX:
			break;

		default:
			printFormat(value, DEC);
	}
}

char transmitByte(char byte)
{
	/* See: spiTransmitData(...) in spi.h */
	/* Transmits a byte via spi (or sci?) and waits for a byte in response. */
	return (char) 0xFF;
}

#define HIGH 1
#define LOW 0
void digitalWrite(uint8_t val,uint8_t pin)
{
	/* Writes val to pin. */
	;
}
void spiSetBitOrder( uint8_t b)
{
	/* This *might* be autogenerated by Halcogen in spi.h's spiInit() already. */
	;
}
void spiSetDataMode( uint8_t mode)
{
	;
}
void spiSetClockDivider( uint8_t div)
{
	;
}

#define MSBFIRST 0
#define SPI_MODE0 0
#define SPI_CLOCK_DIV4 0
#define INPUT 0x00
#define OUTPUT 0x00

void pinMode(uint8_t pin, uint8_t mode)
{
	/* Sets pin to mode. */
	;
}
#define _BV(val) ( 1<<(val) )

/* Wrapper functions for sending data over i2c */

void i2c(uint32_t direction, uint32_t address, uint32_t length, uint8_t* data)
{
	/* Does the heavy lifting for the previous two functions. */

	/* Configure register values */
	i2cSetSlaveAdd(i2cREG1, address);
	i2cSetDirection(i2cREG1, direction);
	i2cSetMode(i2cREG1, I2C_MASTER);
	i2cSetCount(i2cREG1, length);

	/* Transmit a read request, then listen */
	i2cSetStop(i2cREG1);
	i2cSetStart(i2cREG1);
	if(direction == I2C_RECEIVER){
		i2cReceive(i2cREG1, length, data);
	}
	else if( direction == I2C_TRANSMITTER ){
		i2cSend(i2cREG1, length, data);
	}
	/* Generate stop condition */
	while(i2cIsBusBusy(i2cREG1) == true);
	while(i2cIsStopDetected(i2cREG1) == 0);
	i2cClearSCD(i2cREG1);
}

void i2cWrite(uint32_t address, uint32_t length, uint8_t * data)
{
	/* Sends length bytes at data to slave address. */
	i2c(I2C_TRANSMITTER, address, length, data);
}

void i2cRead(uint32_t address, uint32_t length, uint8_t* dest)
{
	/* Reads length bytes to dest from slave address. */
	i2c(I2C_RECEIVER, address, length, dest);
}

float *parseToArrayOfUnknownSize(char *string)
{
	const uint16_t MAX_SIZE = 80;
	/* Todo: Implement more robust solution than "10 curves sounds good enough */
	float *arr = calloc(sizeof(float), MAX_SIZE);
	char *comma = string;
	char *focus = string;
	uint8_t i = 0;

	do{
		arr[i++] = (float)strtod(focus, &comma);
		focus = comma + 1;
	} while(comma != '\0' && i < MAX_SIZE);

	return arr;
}

float *parseToArray(char *string, uint16_t length)
{	/* Parses a length long array out of a string of values, and
	 * returns a pointer to the malloc'd array.
	 */
	float *arr = calloc(sizeof(float), length);
	char *comma = string;
	char *focus = string;

	for(uint16_t i = 0; i < length; i++)
	{
		arr[i] = (float)strtod(focus, &comma);
		if(comma != '\0')
		{
			focus = comma + 1;
		}
		else
		{
			focus = comma; /* Just leave focus at the null char. strtod will handle the rest. */
		}
	}

	return arr;
}

float findAngle(vector vec)
{
	/* Takes a vector, and finds its angle with respect to the positive x-axis. */
	float radians = atan2(-1 * vec.y, vec.x);
	return 180.f * radians / M_PI;
}

float norm (vector point)
{
	/* standard norm of a vector */

	return sqrt(pow(point.x, 2) + pow(point.y, 2));
}

vector diff(vector P1, vector P0)
{
	/* standard vector difference P1 - P0 */
	
	vector difference;
	difference.x = P1.x - P0.x;
	difference.y = P1.y - P0.y;

	return difference;
}

uint8_t max(uint16_t a, uint16_t b)
{
	if( a < b )
	{
		return b;
	}
	else
	{
		return a;
	}
}

uint8_t min(uint16_t a, uint16_t b)
{
	if( a < b )
	{
		return a;
	}
	else
	{
		return b;
	}
}
